:test-examples: ../../test/java/com/rabbitmq/model/docs

[[api-overview]]
== API Overview

=== Environment

The `Environment` is the entry point for applications.
It exposes an API to create connections.

.Environment creation
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=environment-creation]
--------

=== Connection

The `Connection` represents an AMQP 1.0 connection on top of TCP.
It exposes an API to create publishers, consumers, and to manage resources (exchanges, queues, and bindings).

.Connection creation
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-creation]
--------

=== Connection Settings

Connection settings (URI, credentials, etc) can be set at the environment level.
They will then be re-used for each connection.
It is possible to override the environment connection settings for a given connection:

.Connection settings at the environment and connection levels
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-settings]
--------
<1> Use the `guest` user by default
<2> Use the `admin` user for this connection


=== Publishing

.Publisher creation
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=publisher-creation]
--------

.Message creation
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=message-creation]
--------

.Message publishing
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=message-publishing]
--------

.Target address format: exchange and key
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=target-address-exchange-key]
--------
<1> Translates to `/exchange/foo/key/bar`

.Target address format: exchange
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=target-address-exchange]
--------
<1> Translates to `/exchange/foo`

.Target address format: queue
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=target-address-queue]
--------
<1> Translates to `/queue/some-queue`

.Target address format: address in `to` field
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=target-address-null]
--------
<1> No address specified, translates to `null`
<2> Exchange and key automatically set in message `to` field
<3> Exchange automatically set in message `to` field
<4> Queue automatically set in message `to` field

=== Consuming

.Consuming from a queue
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=consumer]
--------
<1> Process the message
<2> Accept (acknowledge) the message

=== Resource Management

The `Management` object is the entry point to deal with resources.
It is accessible from the `Environment`.

.Getting the management object from the environment
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=management]
--------

==== Exchanges

.Exchange creation (built-in type)
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=fanout-exchange]
--------

.Exchange creation (not built-in)
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=delayed-message-exchange]
--------

.Exchange deletion
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=delete-exchange]
--------

==== Queues

.Queue creation
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=queue-creation]
--------

There is no need to remember the argument names and types thanks to explicit configuration methods:

.Queue creation with arguments
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=queue-creation-with-arguments]
--------
<1> Explicit methods for common queue arguments

.Quorum queue creation
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=quorum-queue-creation]
--------
<1> Queue-type-specific configuration helper

.Queue deletion
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=queue-deletion]
--------

==== Bindings

.Exchange-to-queue binding
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=binding]
--------

.Exchange-to-exchange binding
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=exchange-binding]
--------

.Unbinding
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=unbinding]
--------

[[lifecycle-listeners]]
=== Lifecycle Listeners

It is possible to add one or several listeners when creating a `Connection` instance:

.Setting a listener on a connection
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=listener-connection]
--------
<1> Setting a listener
<2> The previous state of the connection
<3> The current (new) state of the connection
<4> The cause of the failure (in case of failure)
<5> The connection instance (as a `Resource`)

It is also possible to set listeners on publisher instances:

.Setting a listener on a publisher
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=listener-publisher]
--------
<1> Setting a listener

And on consumer instances as well:

.Setting a listener on a consumer
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=listener-consumer]
--------
<1> Setting a listener

The listener API is the same for connection, publishers, and consumers.
They all implement the {javadoc-url}/com/rabbitmq/model/Resource.html[`Resource`] marker interface.
The {javadoc-url}/com/rabbitmq/model/Resource.StateListener.html[`StateListener`] interface has only one method that takes a {javadoc-url}/com/rabbitmq/model/Resource.Context.html[`Context`] argument.
See the snippet above for the information available in the `Context`.

A resource {javadoc-url}/com/rabbitmq/model/Resource.State.html[`State`] can have the following values: `OPENING`, `OPEN`, `RECOVERING`, `CLOSING`, `CLOSED`.

=== Recovery

Automatic connection recovery is activated by default: the client will automatically restore a connection after an unexpected closing (e.g. network glitch, node restart, etc).
Automatic topology recovery is also activated as soon as connection recovery is: the client will recreate AMQP entities, as well as publishers and consumers for the recovering connection.
Developers have less to worry about network stability and node restart, as the client will take care of it.

The client tries to reconnect every 5 seconds until it succeeds.
It is possible to change this behavior by providing a custom {javadoc-url}/com/rabbitmq/model/BackOffDelayPolicy.html[`BackOffDelayPolicy`]:

.Setting a back-off policy for connection recovery
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-recovery-back-off]
--------
<1> Configure recovery
<2> Set the back-off delay policy

It is also possible to deactivate topology recovery if it is not appropriate for a given application.
The application would usually register a connection <<lifecycle-listeners,lifecycle listener>> to know when the connection is recovered and recover its own state accordingly.

.Deactivate topology recovery
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-recovery-no-topology-recovery]
--------
<1> Deactivate topology recovery
<2> Restore application state when connection is recovered

It is also possible to deactivate recovery altogether:

.Deactivate recovery
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-recovery-deactivate]
--------
<1> Deactivate recovery



== Dependencies

Use your favorite build management tool to add the client dependencies to your project.

=== Maven

.pom.xml
[source,xml,subs="attributes,specialcharacters"]
----
<dependencies>

  <dependency>
    <groupId>com.rabbitmq.amqp</groupId>
    <artifactId>{project-artifact-id}</artifactId>
    <version>{project-version}</version>
  </dependency>

</dependencies>
----

Snapshots require to declare the <<snapshots,appropriate repository>>.

=== Gradle

.build.gradle
[source,groovy,subs="attributes,specialcharacters"]
----
dependencies {
  compile "com.rabbitmq.amqp:{project-artifact-id}:{project-version}"
}
----

Snapshots require to declare the <<snapshots,appropriate repository>>.

[[snapshots]]
=== Snapshots

Releases are available from Maven Central, which does not require specific declaration.
Snapshots are available from a repository which must be declared in the dependency management configuration.

With Maven:

.Snapshot repository declaration for Maven
[source,xml,subs="attributes,specialcharacters"]
----
<repositories>

  <repository>
    <id>ossrh</id>
    <url>https://oss.sonatype.org/content/repositories/snapshots</url>
    <snapshots><enabled>true</enabled></snapshots>
    <releases><enabled>false</enabled></releases>
  </repository>

</repositories>
----

With Gradle:

.Snapshot repository declaration for Gradle:
[source,groovy,subs="attributes,specialcharacters"]
----
repositories {
  maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
  mavenCentral()
}
----

