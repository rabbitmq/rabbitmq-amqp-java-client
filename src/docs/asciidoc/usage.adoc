:test-examples: ../../test/java/com/rabbitmq/client/amqp/docs

[[api-overview]]
== Overview

The RabbitMQ team maintains a set of AMQP 1.0 client libraries designed and optimized for RabbitMQ.
They offer a simple and safe, yet powerful API on top of AMQP 1.0. Applications can publish and consume messages with these libraries, as well as manage the server topology in a consistent way across programming languages.
The libraries also offer advanced features like automatic connection and topology recovery, and connection affinity with queues.

The RabbitMQ AMQP 1.0 Java Client is one of these libraries.
This documentation covers only the advanced usage of the library; a https://amqp-client-libraries.rabbitmq-website.pages.dev/client-libraries/amqp-client-libraries[common page on the RabbitMQ website] covers the most common use cases.

== Advanced Usage

=== Connection Settings at the Environment Level

Connection settings (URI, credentials, etc) can be set at the environment level.
They will then be re-used for each connection.
It is possible to override the environment connection settings for a given connection:

.Connection settings at the environment and connection levels
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-settings]
--------
<1> Use the `guest` user by default
<2> Use the `admin` user for this connection

[[lifecycle-listeners]]
=== Lifecycle Listeners

It is possible to add one or several listeners when creating a `Connection` instance:

.Setting a listener on a connection
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=listener-connection]
--------
<1> Setting a listener
<2> The previous state of the connection
<3> The current (new) state of the connection
<4> The cause of the failure (in case of failure)
<5> The connection instance (as a `Resource`)

It is also possible to set listeners on publisher instances:

.Setting a listener on a publisher
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=listener-publisher]
--------
<1> Setting a listener

And on consumer instances as well:

.Setting a listener on a consumer
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=listener-consumer]
--------
<1> Setting a listener

The listener API is the same for connection, publishers, and consumers.
They all implement the {javadoc-url}/com/rabbitmq/client/amqp/Resource.html[`Resource`] marker interface.
The {javadoc-url}/com/rabbitmq/client/amqp/Resource.StateListener.html[`StateListener`] interface has only one method that takes a {javadoc-url}/com/rabbitmq/client/amqp/Resource.Context.html[`Context`] argument.
See the snippet above for the information available in the `Context`.

A resource {javadoc-url}/com/rabbitmq/client/amqp/Resource.State.html[`State`] can have the following values: `OPENING`, `OPEN`, `RECOVERING`, `CLOSING`, `CLOSED`.

=== Recovery

Automatic connection recovery is activated by default: the client will automatically restore a connection after an unexpected closing (e.g. network glitch, node restart, etc).
Automatic topology recovery is also activated as soon as connection recovery is: the client will recreate AMQP entities, as well as publishers and consumers for the recovering connection.
Developers have less to worry about network stability and node restart, as the client will take care of it.

The client tries to reconnect every 5 seconds until it succeeds.
It is possible to change this behavior by providing a custom {javadoc-url}/com/rabbitmq/client/amqp/BackOffDelayPolicy.html[`BackOffDelayPolicy`]:

.Setting a back-off policy for connection recovery
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-recovery-back-off]
--------
<1> Configure recovery
<2> Set the back-off delay policy

It is also possible to deactivate topology recovery if it is not appropriate for a given application.
The application would usually register a connection <<lifecycle-listeners,lifecycle listener>> to know when the connection is recovered and recover its own state accordingly.

.Deactivating topology recovery
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-recovery-no-topology-recovery]
--------
<1> Deactivate topology recovery
<2> Restore application state when connection is recovered

It is also possible to deactivate recovery altogether:

.Deactivating recovery
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=connection-recovery-deactivate]
--------
<1> Deactivate recovery

=== Metrics Collection

The library provides the {javadoc-url}/com/rabbitmq/client/amqp/metrics/MetricsCollector.html[`MetricsCollector`] abstraction to collect metrics.
A `MetricsCollector` instance is set at the environment level and is called in several places by the library.
The underlying implementation can then collect, compute and expose metrics.

The library provides the `MicrometerMetricsCollector`, an implementation based on https://micrometer.io/[Micrometer].
Micrometer is a fa√ßade for observability systems: the user can choose the Micrometer meter registry for their favorite system.

Here is how to set up the Micrometer metrics collector and configure it for Prometheus:

.Setting metrics collection with Prometheus
[source,java,indent=0]
--------
include::{test-examples}/Api.java[tag=metrics-micrometer-prometheus]
--------
<1> Create the Micrometer meter registry for Prometheus
<2> Create the metrics collector with the registry
<3> Set the metrics collector in the environment builder
<4> Create a connection, a Micrometer gauge is incremented

The following metrics are recorded:

* the number of open connections
* the number of open publishers
* the number of open consumers
* the total number of published messages
* the total number of accepted published messages
* the total number of failed published messages
* the total number of consumed messages
* the total number of accepted consumed messages
* the total number of requeued consumed messages
* the total number of discarded consumed messages

Here is an example of the Prometheus output:

.Example of the Prometheus output
[source,prometheus]
------
# HELP rabbitmq_amqp_connections
# TYPE rabbitmq_amqp_connections gauge
rabbitmq_amqp_connections 1.0
# HELP rabbitmq_amqp_consumed_total
# TYPE rabbitmq_amqp_consumed_total counter
rabbitmq_amqp_consumed_total 3.0
# HELP rabbitmq_amqp_consumed_accepted_total
# TYPE rabbitmq_amqp_consumed_accepted_total counter
rabbitmq_amqp_consumed_accepted_total 1.0
# HELP rabbitmq_amqp_consumed_discarded_total
# TYPE rabbitmq_amqp_consumed_discarded_total counter
rabbitmq_amqp_consumed_discarded_total 1.0
# HELP rabbitmq_amqp_consumed_requeued_total
# TYPE rabbitmq_amqp_consumed_requeued_total counter
rabbitmq_amqp_consumed_requeued_total 1.0
# HELP rabbitmq_amqp_consumers
# TYPE rabbitmq_amqp_consumers gauge
rabbitmq_amqp_consumers 1.0
# HELP rabbitmq_amqp_published_total
# TYPE rabbitmq_amqp_published_total counter
rabbitmq_amqp_published_total 2.0
# HELP rabbitmq_amqp_published_accepted_total
# TYPE rabbitmq_amqp_published_accepted_total counter
rabbitmq_amqp_published_accepted_total 1.0
# HELP rabbitmq_amqp_published_failed_total
# TYPE rabbitmq_amqp_published_failed_total counter
rabbitmq_amqp_published_failed_total 1.0
# HELP rabbitmq_amqp_publishers
# TYPE rabbitmq_amqp_publishers gauge
rabbitmq_amqp_publishers 1.0
------

=== Remote Procedure Call (RPC)

Remote procedure call with RabbitMQ consists in a client sending a request message and a server replying with a response message.
Both the RPC client and server are _client applications_ and the messages flow through the broker.
The RPC client must send a reply-to queue address with the request.
The RPC server uses this reply-to queue address to send the response.
There must also be a way to correlate a request with its response, this is usually handled with a header that the RPC client and server agree on.

The library provides RPC client and server support classes.
They use sensible defaults and some of the internal mechanics are configurable.
They should meet the requirements of most RPC use cases.
It is still possible to implement one part or the other with regular publishers and consumers for special cases, as this is what the RPC support classes do.

Here is how to create an RPC server instance:

.Creating an RPC server
[source,java,indent=0]
--------
include::{test-examples}/RpcApi.java[tag=rpc-server-creation]
--------
<1> Use builder from connection
<2> Set the queue to consume requests from (it must exist)
<3> Define the processing logic
<4> Create the reply message

Note the RPC server does not create the queue it waits requests on.
It must be created beforehand.

Here is how to create an RPC client:

.Creating an RPC client
[source,java,indent=0]
--------
include::{test-examples}/RpcApi.java[tag=rpc-client-creation]
--------
<1> Use builder from connection
<2> Set the address to send request messages to

The RPC client will send its request to the configured destination.
It can be an exchange or a queue, like in the example above.

Here is how to send a request:

.Sending a request
[source,java,indent=0]
--------
include::{test-examples}/RpcApi.java[tag=rpc-client-request]
--------
<1> Create the message request
<2> Send the request
<3> Wait for the reply (synchronously)

The `RpcClient#publish(Message)` method returns a `CompletableFuture<Message>` that holds the reply message.
It is then possible to wait for the reply asynchronously or synchronously.

The RPC server uses the following defaults:

* it uses the _request_ https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-properties[`message-id` property] for the correlation ID.
* it assigns the correlation ID (so the _request_ `message-id` by default) to the _reply_ https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-properties[`correlation-id` property].
* it assigns the _request_ https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-properties[`reply-to` property] to the _reply_ https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-properties[`to` property] if it is defined.
This behavior is hardcoded but it is possible to cancel it thanks to a reply post-processor.

The RPC client uses the following defaults:

* it creates and waits for replies on an auto-delete, exclusive queue if no reply-to queue is set.
* it uses a string-based correlation ID generator, with a fixed random UUID prefix and a strictly monotonic increasing sequence suffix (`{UUID}-{sequence}`, e.g. `6f839461-6b19-47e1-80b3-6be10d899d85-42`).
The prefix is different for each `RpcClient` instance and the suffix is incremented by one for each request.
* it sets the _request_ https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-properties[`reply-to` property] to the reply-to queue address (defined by the user or created automatically, see above).
* it sets the _request_ https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-properties[`message-id` property] to the generated correlation ID.
* it extracts the correlation ID from the _reply_ https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#type-properties[`correlation-id` property] to correlate a reply with the appropriate request.

Let's see how to customize some of the RPC support mechanics.
Imagine the request `message-id` property is a critical piece of information and we do not want to use it as the correlation ID.
The request can use the `correlation-id` property and the RPC server just has to extract the correlation ID from this property (instead of the `message-id` property by default).
Let's also use a random UUID for the correlation ID generation (avoids doing this in production: this is OK in terms of uniqueness but not optimal in terms of performance because randomness is not cheap).

Here is how to declare the RPC client:

.Customizing the RPC client
[source,java,indent=0]
--------
include::{test-examples}/RpcApi.java[tag=rpc-custom-client-creation]
--------
<1> Declare the reply-to queue
<2> Use a random UUID as correlation ID
<3> Use the `correlation-id` property for the request
<4> Set the `reply-to` property
<5> Set the address to send request messages to

We just have to tell the RPC server to get the correlation ID from the request `correlation-id` property:

.Customizing the RPC server
[source,java,indent=0]
--------
include::{test-examples}/RpcApi.java[tag=rpc-custom-server-creation]
--------
<1> Get the correlation ID from the request `correlation-id` property